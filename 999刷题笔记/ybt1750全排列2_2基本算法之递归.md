## 题目1120：全排列
### 题目描述：
给定一个由不同的小写字母组成的字符串，输出这个字符串的所有全排列。
我们假设对于小写字母有'a' < 'b' < ... < 'y' < 'z'，而且给定的字符串中的字母已经按照从小到大的顺序排列。

### 输入：
输入只有一行，是一个由不同的小写字母组成的字符串，已知字符串的长度在1到6之间。

### 输出：
输出这个字符串的所有排列方式，每行一个排列。要求字母序比较小的排列在前面。字母序如下定义：
已知S = s1s2...sk , T = t1t2...tk，则S < T 等价于，存在p (1 <= p <= k)，使得
s1 = t1, s2 = t2, ..., sp - 1 = tp - 1, sp < tp成立。

### 样例输入：
```
abc
```
### 样例输出：
```
abc
acb
bac
bca
cab
cba
```

### 提示：
每组样例输出结束后要再输出一个回车。

# 思路
一开始是在M.A.Weiss的《数组结构与算法分析（Java）》的第一章里看到这个习题，给出了函数定义，要求使用递归来解。后来又在NOI一本通里看到这道题，进一步要求输出是按字典序，难度提高了一点。

从函数定义上来看，返回值是void，因此只可能是在递归函数中输出结果。另外，递归函数有3个参数，最后的两个指定数组的下标。递归求解的思路是：
1. 递推公式： 从左到右，依次选择排列中的元素
2. 找到出口（base case）：已经排到最后一个元素，无需再排

这一题求解的巧妙之处，一是题目的数据本身就是排好序的，因此，从左到右选择元素时，选好一个元素，就要把这个元素交换到最左边，而这个元素前面的所有元素都需要向后移动。


``` c++
#include <cstdio>

void permute(char str[], int s, int e)
{
	if (s==e)
	{
		for(int i=0;i<=e;i++) printf("%c",str[i]);
		printf("\n");
	}
	else
	{
		int temp;
		for (int j=s;j<=e;j++)
		{
            temp=str[j];
            for(int k=j;k>s;k--)
                str[k]=str[k-1];
            str[s]=temp;

			permute(str,s+1,e);	
            
            temp=str[s];
            for(int k=s;k<j;k++)
                str[k]=str[k+1];
            str[j]=temp;
		}
	}

}

int main(){
	//char str[3] = {'a','b','c'};
	char str[4] = {'a','b','c','d'};
	permute(str,0,3);
	return 0;
}

```